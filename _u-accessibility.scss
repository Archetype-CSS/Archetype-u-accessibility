/**
 * Accessibility
 * 
 */


/**
 * Focus state for keyboard and accessibility
 *
 * https://github.com/jlong/sass-twitter-bootstrap/blob/master/lib/_mixins.scss
 */
%u-tab-focus {
  // Default
  outline: thin dotted #333;
  // Webkit
  outline: 5px auto -webkit-focus-ring-color;
  outline-offset: -2px;
}

/**
 * Image Replacement
 */
%u-ir {
  background-color: transparent;
  border: 0;
  overflow: hidden;
  &:before {
    content: "";
    display: block;
    width: 0;
    height: 150%;
  }
}


/**
 * Hidden
 * 
 * http://www.zeldman.com/2012/03/01/replacing-the-9999px-hack-new-image-replacement/
 * same as compass: @include hide-text(); which includes a hide-left argument
 */
%u-hidden {
  overflow: hidden;
  text-indent: 110%;
  white-space: nowrap;
}


/**
 * Invisable
 *
 * Hide from both screenreaders and browsers: h5bp.com/u 
 * http://www.456bereastreet.com/archive/200711/screen_readers_sometimes_ignore_displaynone
 * http://a11yproject.com/posts/how-to-hide-content
 * 
 * also consider adding: aria-hidden="true" attribute
 */
%u-invisable {
  display: none !important;
  visibility: hidden;
}


/**
 * Visually Hidden
 * 
 * Hide only visually, but have it available for screenreaders: h5bp.com/v 
 * 
 * $focus-state argument extends the .visuallyhidden class
 * allows the element to be focusable when navigated to via the keyboard: h5bp.com/p 
 */
@mixin visuallyHidden($focus-state: null) {
  border: 0; 
  clip: rect(0 0 0 0); 
  height: 1px; 
  margin: -1px; 
  overflow: hidden; 
  padding: 0; 
  position: absolute; 
  width: 1px; 
  @if $focus-state == "focusable" {   
    &:active, 
    &:focus { 
      clip: auto; 
      height: auto; 
      margin: 0; 
      overflow: visible; 
      position: static; 
      width: auto; 
    }
  }
}

%u-visuallyHidden {
  @include visuallyHidden;
}
%u-visuallyHidden-focusable {
  @include visuallyHidden(focusable);
}



/**
 * Progressive Enhancement Text Replace Mixin
 * 
 * $png-path: The path to the pngs for the image sprite, including the *.png (just like normal image sprites)
 * $sprite: The name of the sprite you want to use (this is the file name without extension)
 * $inline-svg: Switches between a Base64 encoded SVG or a normal url() for the SVG. Default to true
 * $with-dimensions: Switches between including dimensions (height/width for all and background-size for SVG) or not -
 * defaults to true.
 * $inline: Whether or not the containing selector is an inline element. Defaults to false.
 */

@mixin replace-text-pe($img-path, $sprite, $inline-svg: true, $with-dimensions: true, $inline-element: false) {
  // Map Out the Sprite
  $png-path: $img-path + '/*.png';
  $sprite-map: sprite-map($png-path);
  
  // Build SVG file name
//  $svg-file: str-replace('*.png', '#{$sprite}.svg', $png-path);
  $svg-file: $img-path + '/#{$sprite}.svg';
  
  // Default Sprite File
  $sprite-file: '' !default;
  
  @if $with-dimensions {
    // Get Sprite File for Height/Width
    $sprite-file: sprite-file($sprite-map, $sprite);

    // Put the height/width of the image in
    width: image-width($sprite-file);
    height: image-height($sprite-file);
  }
  
  // Hide text. Use squish-text() if the element is inline
  @if $inline-element {
    @extend %replace-text-pe-squish;
  }
  @else {
    @extend %replace-text-pe-hide;
  }
  
  // Enhance with SVG
  @include enhance-with('svg') {
    // Inline the SVG so that advanced browsers and future tech doesn't need the extra HTTP requests for the SVG
    @if $inline-svg {
      background-image: inline-image($svg-file);
    }
    @else {
      background-image: image-url($svg-file);
    }
    // No repeating backgrounds, please
    background-repeat: no-repeat;
    // Set background size to ensure that our SVG is the right size.
    @if $with-dimensions {
      background-size: image-width($sprite-file) image-height($sprite-file);
    }
  }
  
  // Degrade from SVG 
  @include degrade-from('svg') {
    // Extend the Sprite Background
    @extend %#{sprite-map-name($sprite-map)}-image-map;
    // Call the Sprite'd image's position.
    @include sprite($sprite-map, $sprite);
  }
}

//////////////////////////////
/**
 * Sprite Map Generator
 * 
 * Need a custom mixin to create extendable classes classes for background image for sprites because dynamic mixin names don't work.
 * $png-path: The path to the pngs for the image sprite, including the *.png (just like normal image sprites)
 */
@mixin sprite-map-generator($img-path) {
  $png-path: $img-path + '/*.png';
  $png-path: sprite-map($png-path);
  %#{sprite-map-name($png-path)}-image-map {
    background: {
      image: $png-path;
      repeat: no-repeat;
    }
  }
}

/**
 * Extendable Class for Squish Text mixin
 */
%replace-text-pe-squish {
  @include squish-text();
}

/**
 * Extendable Class for Hide Text mixin
 */
%replace-text-pe-hide {
  @include hide-text();
}


